plantuml
类之间的关系
泛化(Generalization)
实现(Realization)
依赖(Dependency)
关联(Association)
聚合(Aggregation)
组合(Composition)
另有一说，类的关系有泛化、实现、依赖和关联，关联又分为一般关联关系和聚合关系、组合关系。

泛化
泛化（又叫继承），is-a的关系，表示一个对象是另外一个对象的意思，也就是Java中的继承。泛化是对象之间耦合度最大的一种关系，子类继承父类的所有细节。类和类，接口和接口都可以是继承关系，父类又称作基类或超类，子类又称作派生类，类继承父类后可以实现父类的所以功能，并能拥有父类没有的功能。用带空心三角形的直线来表示，箭头从子类指向父类。最终代码中，泛化关系表现为一个类继承一个非抽象类。如：Father <|-- Son

实现
实现，在java中就是一个接口和实现类之间的关系，接口中一般是没有成员变量，所有操作都是抽象的，只有声明没有具体的实现，具体实现需在实现该接口的类中。在UML中用与类的表示法类似的方式表示接口，区别可在UML中类图中看出。用虚线和带空心的三角形表示，箭头从实现类指向接口。示例：

abstract class AbstractList
interface List
List <|.. AbstractList
abstract class AbstractList
interface List
List <|.. AbstractList
依赖
依赖，是类与类之间最弱的关系，依赖可以简单的理解一个类使用另一个类，这种使用关系具有临时性特征，但一个类又会由于另一个类的改变而受到影响。表现在代码层面，为类B作为参数被类A在某个method中使用，一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。用带箭头的虚线表示依赖，箭头从使用类指向被依赖的类。
如：Human ..> Cigarette

关联
关联，描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；一般用来定义对象之间静态的、天然的结构；是一种强关联的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。表现在代码层面，为被关联类B以类属性（成员变量）的形式出现在关联类A中。表示一个类和另一类是一种包含关系。用带箭头的实线表示，箭头指向被包含类（箭头从使用类指向被关联的类）。分为：1..1表示另一个类的一个对象只与该类的一个对象有关系，0..*表示另一个类的一个对象与该类的零个或多个对象有关系，1..*表示另一个类的一个对象与该类的一个或多个对象有关系，0..1表示另一个类的一个对象没有或只与该类的一个对象有关系，*任意多个对象关联。关联关系默认不强调方向，表示对象间相互知道。

class Water
class Human
Human --> Water
聚合
聚合，关联关系的一种特例，表示整体与部分、拥有的关系，即has-a（或is-part-of）的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期。但是部分可以脱离整体而存在。用带空心菱形的直线表示，菱形从局部指向整体。如：Company o-- Human

组合
组合，关联关系的一种特例，体现一种contains-a（has-a）关系，一种强烈的包含（拥有）关系，比聚合更强，也称为强聚合；同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。此时部分需在整体的构造方法中创建。组合关系是一种强依赖的特殊聚合关系。组合关系用带实心菱形的直线表示，菱形从局部指向整体。如：Human *-- Brain

多重性：Multiplicity，通常在关联、聚合、组合中使用。代表有多少个关联对象存在。使用数字..星号(或者数字)表示。详情见上面的关联关系。

总结
继承、实现这两种关系，体现的是一种类与类、或者类与接口间的纵向关系；其他四种关系则体现的是类与类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准备定位是很难的，这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；其中聚合和组合尤其难区分。
总的来说，后几种关系所表现的强弱程度依次为：组合 > 聚合 > 关联 > 依赖。
聚合和组合的区别
聚合是has-a关系，组合是contains-a关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除聚合对象不一定就删除代表部分事物的对象。组合关系中一旦删除组合对象，同时也就删除代表部分事物的对象。

组合和继承
封装、继承、多态是面向对象的三个特征；Java代码的复用有继承，组合以及代理三种具体的表现形式，继承可以实现类的复用。所以，很多开发人员在需要复用一些代码的时候会很自然的使用类的继承的方式。但是长期大量的使用继承会给代码带来很高的维护成本。

在继承结构中，父类的内部细节对于子类是可见的。所以通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致子类行为的不可预知性；）
组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）
继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低应用的灵活性。）
组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。
